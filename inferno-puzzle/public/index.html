<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üî• Inferno Puzzle - Collaborative Puzzle Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --fire-orange: #FF6B35; --fire-yellow: #F7C531; --fire-red: #E83F6F;
      --coal: #1a1a1a; --ash: #2d2d2d; --smoke: #3d3d3d; --charcoal: #252525;
    }
    html, body { height: 100%; overflow: hidden; font-family: 'Rajdhani', sans-serif; background: var(--coal); color: #fff; }
    body {
      background: radial-gradient(ellipse at bottom, rgba(255, 69, 0, 0.15) 0%, transparent 60%),
        radial-gradient(ellipse at top right, rgba(247, 197, 49, 0.08) 0%, transparent 40%),
        linear-gradient(180deg, #0d0d0d 0%, #1a1a1a 50%, #1f1510 100%);
    }
    .fire-particles { position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden; }
    .ember-particle {
      position: absolute; width: 4px; height: 4px; background: var(--fire-orange); border-radius: 50%;
      filter: blur(1px); animation: float-up 4s ease-in infinite;
      box-shadow: 0 0 6px var(--fire-orange), 0 0 12px var(--fire-yellow);
    }
    @keyframes float-up {
      0% { transform: translateY(100vh) scale(1); opacity: 0; }
      10% { opacity: 1; } 90% { opacity: 1; }
      100% { transform: translateY(-20vh) scale(0); opacity: 0; }
    }
    .header {
      position: fixed; top: 0; left: 0; right: 0; height: 60px;
      background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
      backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255, 107, 53, 0.3);
      display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 1000;
    }
    .logo {
      font-family: 'Cinzel', serif; font-size: 1.8rem; font-weight: 900;
      background: linear-gradient(135deg, var(--fire-yellow) 0%, var(--fire-orange) 50%, var(--fire-red) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 2px;
    }
    .logo::before { content: 'üî• '; -webkit-text-fill-color: initial; }
    .header-controls { display: flex; gap: 10px; align-items: center; }
    .btn {
      font-family: 'Rajdhani', sans-serif; font-weight: 600; font-size: 0.9rem;
      padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;
      transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;
    }
    .btn-fire {
      background: linear-gradient(135deg, var(--fire-orange) 0%, var(--fire-red) 100%);
      color: #fff; box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
    }
    .btn-fire:hover { transform: translateY(-2px); box-shadow: 0 6px 25px rgba(255, 107, 53, 0.6); }
    .btn-ghost { background: transparent; color: var(--fire-orange); border: 1px solid var(--fire-orange); }
    .btn-ghost:hover { background: rgba(255, 107, 53, 0.1); }
    .game-info {
      position: fixed; top: 60px; left: 0; right: 0; height: 50px;
      background: rgba(0,0,0,0.6); border-bottom: 1px solid rgba(255, 107, 53, 0.2);
      display: none; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 999;
    }
    .game-info.active { display: flex; }
    .game-title { font-family: 'Cinzel', serif; font-size: 1.1rem; color: var(--fire-yellow); }
    .game-code {
      font-family: monospace; font-size: 1.2rem; background: var(--ash);
      padding: 4px 12px; border-radius: 4px; color: var(--fire-orange);
      border: 1px solid rgba(255, 107, 53, 0.3); letter-spacing: 2px;
    }
    .progress-container { display: flex; align-items: center; gap: 10px; flex: 1; max-width: 300px; margin: 0 20px; }
    .progress-bar { flex: 1; height: 8px; background: var(--ash); border-radius: 4px; overflow: hidden; }
    .progress-fill {
      height: 100%; background: linear-gradient(90deg, var(--fire-orange), var(--fire-yellow));
      border-radius: 4px; transition: width 0.5s ease; box-shadow: 0 0 10px var(--fire-orange);
    }
    .progress-text { font-weight: 700; color: var(--fire-yellow); min-width: 50px; text-align: right; }
    .players-panel {
      position: fixed; top: 120px; right: 10px; width: 200px; background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255, 107, 53, 0.3); border-radius: 8px; padding: 15px; z-index: 998; display: none;
    }
    .players-panel.active { display: block; }
    .players-title { font-family: 'Cinzel', serif; font-size: 0.9rem; color: var(--fire-orange); margin-bottom: 10px; text-transform: uppercase; }
    .player-item { display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 0.85rem; }
    .player-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
    .player-you { color: var(--fire-yellow); font-weight: 600; }
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex;
      align-items: center; justify-content: center; z-index: 2000;
      opacity: 0; visibility: hidden; transition: all 0.3s ease;
    }
    .modal-overlay.active { opacity: 1; visibility: visible; }
    .modal {
      background: linear-gradient(180deg, var(--charcoal) 0%, var(--coal) 100%);
      border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 12px; padding: 30px;
      max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
      transform: scale(0.9); transition: transform 0.3s ease; box-shadow: 0 0 60px rgba(255, 107, 53, 0.2);
    }
    .modal-overlay.active .modal { transform: scale(1); }
    .modal-title {
      font-family: 'Cinzel', serif; font-size: 1.5rem; color: var(--fire-orange);
      margin-bottom: 20px; text-align: center; text-transform: uppercase; letter-spacing: 2px;
    }
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-bottom: 6px; text-transform: uppercase; }
    .form-input {
      width: 100%; padding: 12px; background: var(--ash); border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 6px; color: #fff; font-family: 'Rajdhani', sans-serif; font-size: 1rem;
    }
    .form-input:focus { outline: none; border-color: var(--fire-orange); box-shadow: 0 0 15px rgba(255, 107, 53, 0.3); }
    .form-input::file-selector-button {
      background: var(--fire-orange); color: #fff; border: none; padding: 8px 16px;
      border-radius: 4px; cursor: pointer; font-family: 'Rajdhani', sans-serif; font-weight: 600; margin-right: 10px;
    }
    .piece-slider { -webkit-appearance: none; width: 100%; height: 8px; background: var(--ash); border-radius: 4px; }
    .piece-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px;
      background: linear-gradient(135deg, var(--fire-orange), var(--fire-red));
      border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--fire-orange);
    }
    .piece-count-display { text-align: center; font-size: 2rem; font-weight: 700; color: var(--fire-yellow); margin: 10px 0; }
    .image-preview { width: 100%; max-height: 150px; object-fit: contain; border-radius: 6px; margin-top: 10px; display: none; }
    .btn-row { display: flex; gap: 10px; margin-top: 20px; }
    .btn-row .btn { flex: 1; }
    .saved-games-list { max-height: 300px; overflow-y: auto; }
    .saved-game-item {
      display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--ash);
      border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s ease; border: 1px solid transparent;
    }
    .saved-game-item:hover { border-color: var(--fire-orange); transform: translateX(5px); }
    .saved-game-thumb { width: 60px; height: 45px; object-fit: cover; border-radius: 4px; }
    .saved-game-info { flex: 1; }
    .saved-game-name { font-weight: 600; color: var(--fire-yellow); }
    .saved-game-meta { font-size: 0.8rem; color: rgba(255,255,255,0.5); }
    .saved-game-progress { font-weight: 700; color: var(--fire-orange); }
    .no-games { text-align: center; color: rgba(255,255,255,0.5); padding: 30px; }
    .main-menu { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
    .main-menu.hidden { display: none; }
    .menu-logo {
      font-family: 'Cinzel', serif; font-size: 4rem; font-weight: 900;
      background: linear-gradient(135deg, var(--fire-yellow) 0%, var(--fire-orange) 50%, var(--fire-red) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px;
      animation: pulse-glow 2s ease-in-out infinite;
    }
    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 107, 53, 0.6)); }
      50% { filter: drop-shadow(0 0 40px rgba(255, 107, 53, 0.9)); }
    }
    .menu-subtitle { font-size: 1.2rem; color: rgba(255,255,255,0.6); margin-bottom: 50px; letter-spacing: 4px; text-transform: uppercase; }
    .menu-buttons { display: flex; flex-direction: column; gap: 15px; width: 280px; }
    .menu-btn { padding: 16px 32px; font-size: 1.1rem; border-radius: 8px; }
    .join-input-group { display: flex; gap: 10px; margin-top: 15px; }
    .join-input {
      flex: 1; padding: 12px; background: var(--ash); border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 6px; color: #fff; font-family: monospace; font-size: 1.1rem;
      text-transform: uppercase; letter-spacing: 2px; text-align: center;
    }
    .puzzle-container { position: fixed; inset: 0; top: 110px; display: none; overflow: hidden; cursor: grab; }
    .puzzle-container.active { display: block; }
    .puzzle-canvas { position: absolute; transform-origin: 0 0; }
    .puzzle-board {
      position: absolute; left: 50px; top: 50px;
      border: 3px solid rgba(255, 107, 53, 0.5);
      background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3));
      box-shadow: 0 0 50px rgba(255, 107, 53, 0.2), inset 0 0 100px rgba(0,0,0,0.5);
      border-radius: 4px;
    }
    .puzzle-piece {
      position: absolute; cursor: grab; transition: filter 0.2s ease;
      filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.6));
    }
    .puzzle-piece:hover { z-index: 100; filter: drop-shadow(0 0 15px rgba(255, 107, 53, 0.8)) drop-shadow(2px 3px 4px rgba(0,0,0,0.6)); }
    .puzzle-piece.dragging { cursor: grabbing; z-index: 1000; filter: drop-shadow(0 0 20px rgba(255, 107, 53, 1)) drop-shadow(5px 10px 20px rgba(0,0,0,0.7)); }
    .puzzle-piece.placed { cursor: default; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3)); }
    .puzzle-piece.locked { filter: drop-shadow(0 0 10px var(--lock-color)) drop-shadow(2px 3px 4px rgba(0,0,0,0.6)); }
    .remote-cursor { position: absolute; pointer-events: none; z-index: 2000; transition: transform 0.1s linear; }
    .cursor-dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 10px currentColor; }
    .cursor-name { position: absolute; left: 16px; top: -4px; font-size: 0.75rem; background: currentColor; color: #000; padding: 2px 6px; border-radius: 4px; white-space: nowrap; font-weight: 600; }
    .zoom-controls { position: fixed; bottom: 20px; right: 20px; display: none; flex-direction: column; gap: 8px; z-index: 999; }
    .zoom-controls.active { display: flex; }
    .zoom-btn { width: 40px; height: 40px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 8px; color: var(--fire-orange); font-size: 1.4rem; cursor: pointer; }
    .zoom-btn:hover { background: var(--fire-orange); color: #fff; }
    .victory-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex;
      flex-direction: column; align-items: center; justify-content: center;
      z-index: 3000; opacity: 0; visibility: hidden; transition: all 0.5s ease;
    }
    .victory-overlay.active { opacity: 1; visibility: visible; }
    .victory-title {
      font-family: 'Cinzel', serif; font-size: 4rem;
      background: linear-gradient(135deg, var(--fire-yellow), var(--fire-orange), var(--fire-red));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      animation: victory-pulse 1s ease-in-out infinite;
    }
    @keyframes victory-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .victory-subtitle { font-size: 1.5rem; color: rgba(255,255,255,0.7); margin: 20px 0 40px; }
    .minimap { position: fixed; bottom: 20px; left: 20px; width: 150px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 8px; padding: 8px; display: none; z-index: 999; }
    .minimap.active { display: block; }
    .minimap-image { width: 100%; border-radius: 4px; opacity: 0.8; }
    .minimap-title { font-size: 0.7rem; color: rgba(255,255,255,0.5); text-align: center; margin-top: 4px; text-transform: uppercase; }
    .toast-container { position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 2500; display: flex; flex-direction: column; gap: 10px; }
    .toast { background: rgba(0,0,0,0.9); border: 1px solid var(--fire-orange); padding: 12px 24px; border-radius: 8px; color: #fff; font-weight: 500; animation: toast-in 0.3s ease, toast-out 0.3s ease 2.7s forwards; box-shadow: 0 0 20px rgba(255, 107, 53, 0.4); }
    @keyframes toast-in { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes toast-out { from { opacity: 1; } to { opacity: 0; } }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: var(--coal); }
    ::-webkit-scrollbar-thumb { background: var(--fire-orange); border-radius: 4px; }
  </style>
</head>
<body>
  <div class="fire-particles" id="fireParticles"></div>
  <header class="header">
    <div class="logo">INFERNO PUZZLE</div>
    <div class="header-controls">
      <button class="btn btn-ghost" id="btnHome" style="display:none">‚Üê Menu</button>
      <button class="btn btn-ghost" id="btnUpdateImage" style="display:none">Update Image</button>
      <button class="btn btn-fire" id="btnShare" style="display:none">Share Code</button>
    </div>
  </header>
  <div class="game-info" id="gameInfo">
    <div class="game-title" id="gameTitle">Loading...</div>
    <div class="progress-container">
      <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
      <span class="progress-text" id="progressText">0%</span>
    </div>
    <div class="game-code" id="gameCodeDisplay">--------</div>
  </div>
  <div class="players-panel" id="playersPanel">
    <div class="players-title">üî• Players Online</div>
    <div id="playersList"></div>
  </div>
  <div class="main-menu" id="mainMenu">
    <div class="menu-logo">üî• INFERNO</div>
    <div class="menu-subtitle">Collaborative Puzzle</div>
    <div class="menu-buttons">
      <button class="btn btn-fire menu-btn" id="btnNewGame">üéÆ New Game</button>
      <button class="btn btn-ghost menu-btn" id="btnLoadGame">üìÇ Load Game</button>
      <div class="join-input-group">
        <input type="text" class="join-input" id="joinCodeInput" placeholder="CODE" maxlength="8">
        <button class="btn btn-fire" id="btnJoinGame">Join</button>
      </div>
    </div>
  </div>
  <div class="puzzle-container" id="puzzleContainer">
    <div class="puzzle-canvas" id="puzzleCanvas">
      <div class="puzzle-board" id="puzzleBoard"></div>
    </div>
  </div>
  <div class="zoom-controls" id="zoomControls">
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomOut">‚àí</button>
    <button class="zoom-btn" id="zoomReset">‚ü≤</button>
  </div>
  <div class="minimap" id="minimap">
    <img class="minimap-image" id="minimapImage" src="" alt="Reference">
    <div class="minimap-title">Reference</div>
  </div>
  <div class="modal-overlay" id="newGameModal">
    <div class="modal">
      <h2 class="modal-title">üî• Create New Puzzle</h2>
      <div class="form-group"><label class="form-label">Puzzle Name</label><input type="text" class="form-input" id="gameName" placeholder="My Awesome Puzzle"></div>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="playerName" placeholder="Enter your name"></div>
      <div class="form-group"><label class="form-label">Upload Image</label><input type="file" class="form-input" id="imageUpload" accept="image/*"><img class="image-preview" id="imagePreview"></div>
      <div class="form-group">
        <label class="form-label">Number of Pieces</label>
        <input type="range" class="piece-slider" id="pieceSlider" min="25" max="250" value="100" step="25">
        <div class="piece-count-display" id="pieceCountDisplay">100 pieces</div>
      </div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelNewGame">Cancel</button><button class="btn btn-fire" id="createGame">Create Puzzle</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="loadGameModal">
    <div class="modal">
      <h2 class="modal-title">üìÇ Load Saved Game</h2>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="loadPlayerName" placeholder="Enter your name"></div>
      <div class="saved-games-list" id="savedGamesList"><div class="no-games">Loading...</div></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelLoadGame">Cancel</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="updateImageModal">
    <div class="modal">
      <h2 class="modal-title">üñºÔ∏è Update Puzzle Image</h2>
      <p style="color:rgba(255,255,255,0.6);margin-bottom:20px;text-align:center;">Warning: This will reset all progress!</p>
      <div class="form-group"><label class="form-label">New Image</label><input type="file" class="form-input" id="newImageUpload" accept="image/*"><img class="image-preview" id="newImagePreview"></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelUpdateImage">Cancel</button><button class="btn btn-fire" id="confirmUpdateImage">Update</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="joinNameModal">
    <div class="modal">
      <h2 class="modal-title">üî• Join Puzzle</h2>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="joinPlayerName" placeholder="Enter your name"></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelJoin">Cancel</button><button class="btn btn-fire" id="confirmJoin">Join Game</button></div>
    </div>
  </div>
  <div class="victory-overlay" id="victoryOverlay">
    <div class="victory-title">üî• COMPLETE! üî•</div>
    <div class="victory-subtitle">Congratulations!</div>
    <button class="btn btn-fire menu-btn" id="victoryHome">Back to Menu</button>
  </div>
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // Fire particles
    (() => {
      const c = document.getElementById('fireParticles');
      for (let i = 0; i < 30; i++) {
        const p = document.createElement('div');
        p.className = 'ember-particle';
        p.style.left = Math.random() * 100 + '%';
        p.style.animationDelay = Math.random() * 4 + 's';
        p.style.animationDuration = (3 + Math.random() * 3) + 's';
        c.appendChild(p);
      }
    })();

    // State
    let socket = null, currentGame = null, myPlayerId = null;
    let playerName = localStorage.getItem('playerName') || '';
    let pieceElements = new Map(), remoteCursors = new Map(), puzzleImage = null;
    let edgeCache = null, pieceGroups = new Map(), pieceToPieceGroup = new Map();
    let nextGroupId = 1, pieceWidth = 0, pieceHeight = 0, tabSize = 0;
    let canvasScale = 1, canvasX = 0, canvasY = 0, isDraggingCanvas = false, lastMouseX = 0, lastMouseY = 0;
    let draggedPiece = null, draggedGroup = null, dragOffsetX = 0, dragOffsetY = 0;

    const puzzleContainer = document.getElementById('puzzleContainer');
    const puzzleCanvas = document.getElementById('puzzleCanvas');
    const puzzleBoard = document.getElementById('puzzleBoard');

    // Seeded random number generator
    function createRandom(seed) {
      return () => { seed = (seed * 1103515245 + 12345) & 0x7fffffff; return seed / 0x7fffffff; };
    }

    // Generate edge curve using B-spline approach from Inventables
    // Returns array of points representing a knobby edge
    function generateEdgeCurve(rand) {
      // Randomize control point positions within good regions
      // Based on: http://dev.inventables.com/2016/02/26/generating-svg-jigsaw-puzzles.html
      const randomBetween = (min, max) => rand() * (max - min) + min;
      
      // Baseline (neck) region offsets
      const baseL = { xMin: 0.38, xMax: 0.45, yMin: -0.12, yMax: 0.02 };
      const baseR = { xMin: 0.55, xMax: 0.62, yMin: -0.12, yMax: 0.02 };
      
      // Upper (head) region offsets  
      const upperL = { xMin: 0.20, xMax: 0.35, yMin: 0.20, yMax: 0.38 };
      const upperR = { xMin: 0.65, xMax: 0.80, yMin: 0.20, yMax: 0.38 };
      
      // Direction: 1 = tab out, -1 = tab in (socket)
      const dir = rand() < 0.5 ? 1 : -1;
      
      // Generate 6 control points for B-spline
      const points = [
        [0, 0],
        [randomBetween(baseL.xMin, baseL.xMax), randomBetween(baseL.yMin, baseL.yMax) * dir],
        [randomBetween(upperL.xMin, upperL.xMax), randomBetween(upperL.yMin, upperL.yMax) * dir],
        [randomBetween(upperR.xMin, upperR.xMax), randomBetween(upperR.yMin, upperR.yMax) * dir],
        [randomBetween(baseR.xMin, baseR.xMax), randomBetween(baseR.yMin, baseR.yMax) * dir],
        [1, 0]
      ];
      
      return { points, dir };
    }

    // Generate all edges for the puzzle grid
    function generateEdges(rows, cols, seed) {
      const rand = createRandom(seed);
      
      // Horizontal edges (rows + 1 sets of cols edges)
      const horizontal = [];
      for (let r = 0; r <= rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          if (r === 0 || r === rows) {
            // Flat edge (border)
            row.push({ points: [[0, 0], [1, 0]], dir: 0 });
          } else {
            row.push(generateEdgeCurve(rand));
          }
        }
        horizontal.push(row);
      }
      
      // Vertical edges (rows sets of cols + 1 edges)
      const vertical = [];
      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c <= cols; c++) {
          if (c === 0 || c === cols) {
            // Flat edge (border)
            row.push({ points: [[0, 0], [1, 0]], dir: 0 });
          } else {
            row.push(generateEdgeCurve(rand));
          }
        }
        vertical.push(row);
      }
      
      return { horizontal, vertical };
    }

    // Convert B-spline control points to smooth curve using Catmull-Rom
    function bsplineToBezier(points, scale, offsetX, offsetY, horizontal, flip) {
      const result = [];
      const n = points.length;
      
      for (let i = 0; i < n - 1; i++) {
        const p0 = points[Math.max(0, i - 1)];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[Math.min(n - 1, i + 2)];
        
        // Catmull-Rom to Bezier conversion
        const cp1 = [
          p1[0] + (p2[0] - p0[0]) / 6,
          p1[1] + (p2[1] - p0[1]) / 6
        ];
        const cp2 = [
          p2[0] - (p3[0] - p1[0]) / 6,
          p2[1] - (p3[1] - p1[1]) / 6
        ];
        
        // Transform points based on orientation
        const transform = (pt) => {
          let x, y;
          if (horizontal) {
            x = (flip ? 1 - pt[0] : pt[0]) * scale + offsetX;
            y = (flip ? -pt[1] : pt[1]) * scale + offsetY;
          } else {
            x = (flip ? -pt[1] : pt[1]) * scale + offsetX;
            y = (flip ? 1 - pt[0] : pt[0]) * scale + offsetY;
          }
          return [x, y];
        };
        
        result.push({
          start: transform(p1),
          cp1: transform(cp1),
          cp2: transform(cp2),
          end: transform(p2)
        });
      }
      
      return result;
    }

    // Draw piece path using the edge curves
    function createPiecePath(ctx, row, col, w, h, edges) {
      const { horizontal, vertical } = edges;
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      
      // Top edge (left to right)
      const topEdge = horizontal[row][col];
      const topCurves = bsplineToBezier(topEdge.points, w, 0, 0, true, false);
      for (const c of topCurves) {
        ctx.bezierCurveTo(c.cp1[0], c.cp1[1], c.cp2[0], c.cp2[1], c.end[0], c.end[1]);
      }
      
      // Right edge (top to bottom)
      const rightEdge = vertical[row][col + 1];
      const rightCurves = bsplineToBezier(rightEdge.points, h, w, 0, false, false);
      for (const c of rightCurves) {
        ctx.bezierCurveTo(c.cp1[0], c.cp1[1], c.cp2[0], c.cp2[1], c.end[0], c.end[1]);
      }
      
      // Bottom edge (right to left)
      const bottomEdge = horizontal[row + 1][col];
      const bottomCurves = bsplineToBezier(bottomEdge.points, w, 0, h, true, true);
      for (const c of bottomCurves) {
        ctx.bezierCurveTo(c.cp1[0], c.cp1[1], c.cp2[0], c.cp2[1], c.end[0], c.end[1]);
      }
      
      // Left edge (bottom to top)
      const leftEdge = vertical[row][col];
      const leftCurves = bsplineToBezier(leftEdge.points, h, 0, 0, false, true);
      for (const c of leftCurves) {
        ctx.bezierCurveTo(c.cp1[0], c.cp1[1], c.cp2[0], c.cp2[1], c.end[0], c.end[1]);
      }
      
      ctx.closePath();
    }

    function showToast(msg) {
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = msg;
      document.getElementById('toastContainer').appendChild(t);
      setTimeout(() => t.remove(), 3000);
    }

    function openModal(id) { document.getElementById(id).classList.add('active'); }
    function closeModal(id) { document.getElementById(id).classList.remove('active'); }

    // Socket
    function connectSocket() {
      socket = io();
      
      socket.on('game:state', (game) => {
        currentGame = game;
        myPlayerId = game.yourId;
        pieceGroups.clear(); pieceToPieceGroup.clear();
        if (game.groups) {
          game.groups.forEach((g, i) => {
            const gid = i + 1;
            pieceGroups.set(gid, new Set(g.pieceIds));
            g.pieceIds.forEach(pid => pieceToPieceGroup.set(pid, gid));
          });
          nextGroupId = game.groups.length + 1;
        }
        renderGame();
        showToast('Joined: ' + game.name);
      });

      socket.on('player:joined', (p) => { if (p.id !== myPlayerId) showToast(p.name + ' joined!'); });
      socket.on('player:left', ({ playerId }) => { remoteCursors.get(playerId)?.remove(); remoteCursors.delete(playerId); });
      socket.on('players:update', (players) => { currentGame.players = players; renderPlayers(); });

      socket.on('piece:grabbed', ({ pieceId, playerId }) => {
        const p = currentGame.pieces.find(x => x.id === pieceId);
        if (p) p.lockedBy = playerId;
        updatePieceLock(pieceId, playerId);
      });

      socket.on('piece:moved', ({ pieceId, x, y, groupPieces }) => {
        if (groupPieces) {
          groupPieces.forEach(gp => {
            const p = currentGame.pieces.find(x => x.id === gp.id);
            if (p) { p.currentX = gp.x; p.currentY = gp.y; }
            const el = pieceElements.get(gp.id);
            if (el) { el.style.left = (gp.x - tabSize) + 'px'; el.style.top = (gp.y - tabSize) + 'px'; }
          });
        } else {
          const p = currentGame.pieces.find(x => x.id === pieceId);
          if (p) { p.currentX = x; p.currentY = y; }
          const el = pieceElements.get(pieceId);
          if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        }
      });

      socket.on('piece:released', ({ pieceId, x, y, placed, progress, groupPieces, newGroup }) => {
        const updates = groupPieces || [{ id: pieceId, x, y, placed }];
        updates.forEach(u => {
          const p = currentGame.pieces.find(x => x.id === u.id);
          if (p) { p.currentX = u.x; p.currentY = u.y; p.isPlaced = u.placed; p.lockedBy = null; }
          const el = pieceElements.get(u.id);
          if (el) {
            el.style.left = (u.x - tabSize) + 'px';
            el.style.top = (u.y - tabSize) + 'px';
            el.classList.remove('locked');
            if (u.placed) el.classList.add('placed');
          }
        });
        if (newGroup?.pieceIds) {
          const gid = nextGroupId++;
          pieceGroups.set(gid, new Set(newGroup.pieceIds));
          newGroup.pieceIds.forEach(pid => pieceToPieceGroup.set(pid, gid));
        }
        updateProgress(progress);
      });

      socket.on('cursor:update', ({ playerId, x, y }) => updateRemoteCursor(playerId, x, y));
      socket.on('game:reset', ({ imageUrl, pieces }) => {
        currentGame.imageUrl = imageUrl; currentGame.pieces = pieces;
        pieceGroups.clear(); pieceToPieceGroup.clear(); nextGroupId = 1;
        edgeCache = null;
        renderPuzzle();
        document.getElementById('minimapImage').src = imageUrl;
        showToast('Puzzle reset!');
      });
      socket.on('game:complete', () => document.getElementById('victoryOverlay').classList.add('active'));
      socket.on('error', ({ message }) => showToast('Error: ' + message));
    }

    function updateRemoteCursor(playerId, x, y) {
      let cursor = remoteCursors.get(playerId);
      const player = currentGame?.players.find(p => p.id === playerId);
      if (!cursor && player) {
        cursor = document.createElement('div');
        cursor.className = 'remote-cursor';
        cursor.innerHTML = `<div class="cursor-dot" style="background:${player.color}"></div><div class="cursor-name" style="background:${player.color}">${player.name}</div>`;
        puzzleCanvas.appendChild(cursor);
        remoteCursors.set(playerId, cursor);
      }
      if (cursor) cursor.style.transform = `translate(${x}px,${y}px)`;
    }

    function renderGame() {
      document.getElementById('mainMenu').classList.add('hidden');
      puzzleContainer.classList.add('active');
      document.getElementById('gameInfo').classList.add('active');
      document.getElementById('playersPanel').classList.add('active');
      document.getElementById('zoomControls').classList.add('active');
      document.getElementById('minimap').classList.add('active');
      document.getElementById('btnHome').style.display = 'block';
      document.getElementById('btnUpdateImage').style.display = 'block';
      document.getElementById('btnShare').style.display = 'block';
      document.getElementById('gameTitle').textContent = currentGame.name;
      document.getElementById('gameCodeDisplay').textContent = currentGame.id;
      document.getElementById('minimapImage').src = currentGame.imageUrl;
      updateProgress(currentGame.progress);
      renderPlayers();
      renderPuzzle();
      canvasScale = 0.8; canvasX = 50; canvasY = 20;
      updateCanvasTransform();
    }

    function renderPlayers() {
      document.getElementById('playersList').innerHTML = currentGame.players.map(p =>
        `<div class="player-item"><div class="player-dot" style="background:${p.color}"></div><span class="${p.id===myPlayerId?'player-you':''}">${p.name}${p.id===myPlayerId?' (You)':''}</span></div>`
      ).join('');
    }

    function renderPuzzle() {
      pieceElements.forEach(el => el.remove());
      pieceElements.clear();
      
      const { cols, rows } = currentGame.gridSize;
      pieceWidth = 800 / cols;
      pieceHeight = 600 / rows;
      tabSize = Math.min(pieceWidth, pieceHeight) * 0.25;
      
      puzzleBoard.style.width = '800px';
      puzzleBoard.style.height = '600px';
      
      // Generate edges with game ID as seed
      const seed = currentGame.id.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
      edgeCache = generateEdges(rows, cols, seed);
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => { puzzleImage = img; currentGame.pieces.forEach(p => createPieceElement(p)); };
      img.src = currentGame.imageUrl;
    }

    function createPieceElement(piece) {
      if (!puzzleImage || !edgeCache) return;
      
      const { cols } = currentGame.gridSize;
      const row = Math.floor(piece.id / cols);
      const col = piece.id % cols;
      
      const extW = pieceWidth + tabSize * 2;
      const extH = pieceHeight + tabSize * 2;
      const canvas = document.createElement('canvas');
      canvas.width = extW;
      canvas.height = extH;
      const ctx = canvas.getContext('2d');
      
      ctx.translate(tabSize, tabSize);
      
      // Create and clip to piece shape
      createPiecePath(ctx, row, col, pieceWidth, pieceHeight, edgeCache);
      ctx.save();
      ctx.clip();
      
      // Draw image
      const sx = (piece.correctCol / currentGame.gridSize.cols) * puzzleImage.width;
      const sy = (piece.correctRow / currentGame.gridSize.rows) * puzzleImage.height;
      const sw = puzzleImage.width / currentGame.gridSize.cols;
      const sh = puzzleImage.height / currentGame.gridSize.rows;
      ctx.drawImage(puzzleImage, sx, sy, sw, sh, 0, 0, pieceWidth, pieceHeight);
      ctx.restore();
      
      // Draw border
      createPiecePath(ctx, row, col, pieceWidth, pieceHeight, edgeCache);
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      createPiecePath(ctx, row, col, pieceWidth, pieceHeight, edgeCache);
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
      
      const el = document.createElement('div');
      el.className = 'puzzle-piece' + (piece.isPlaced ? ' placed' : '');
      el.style.width = extW + 'px';
      el.style.height = extH + 'px';
      el.style.left = (piece.currentX - tabSize) + 'px';
      el.style.top = (piece.currentY - tabSize) + 'px';
      el.style.backgroundImage = `url(${canvas.toDataURL()})`;
      el.style.backgroundSize = 'cover';
      el.dataset.pieceId = piece.id;
      
      if (piece.lockedBy && piece.lockedBy !== myPlayerId) {
        const player = currentGame.players.find(p => p.id === piece.lockedBy);
        if (player) { el.classList.add('locked'); el.style.setProperty('--lock-color', player.color); }
      }
      
      el.addEventListener('mousedown', onPieceMouseDown);
      el.addEventListener('touchstart', onPieceTouchStart, { passive: false });
      puzzleCanvas.appendChild(el);
      pieceElements.set(piece.id, el);
    }

    function updatePieceLock(pieceId, playerId) {
      const el = pieceElements.get(pieceId);
      if (!el) return;
      if (playerId && playerId !== myPlayerId) {
        const player = currentGame.players.find(p => p.id === playerId);
        if (player) { el.classList.add('locked'); el.style.setProperty('--lock-color', player.color); }
      } else el.classList.remove('locked');
    }

    function updateProgress(progress) {
      currentGame.progress = progress;
      document.getElementById('progressFill').style.width = progress + '%';
      document.getElementById('progressText').textContent = progress + '%';
    }

    function updateCanvasTransform() {
      puzzleCanvas.style.transform = `translate(${canvasX}px,${canvasY}px) scale(${canvasScale})`;
    }

    // Canvas pan/zoom
    puzzleContainer.addEventListener('mousedown', (e) => {
      if (e.target === puzzleContainer || e.target === puzzleCanvas || e.target === puzzleBoard) {
        isDraggingCanvas = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
        puzzleContainer.style.cursor = 'grabbing';
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDraggingCanvas) {
        canvasX += e.clientX - lastMouseX; canvasY += e.clientY - lastMouseY;
        lastMouseX = e.clientX; lastMouseY = e.clientY;
        updateCanvasTransform();
      }
      if (currentGame && socket) {
        const rect = puzzleCanvas.getBoundingClientRect();
        socket.emit('cursor:move', { x: (e.clientX - rect.left) / canvasScale, y: (e.clientY - rect.top) / canvasScale });
      }
    });

    document.addEventListener('mouseup', () => { isDraggingCanvas = false; puzzleContainer.style.cursor = 'grab'; });
    puzzleContainer.addEventListener('wheel', (e) => {
      e.preventDefault();
      canvasScale = Math.max(0.3, Math.min(3, canvasScale * (e.deltaY > 0 ? 0.9 : 1.1)));
      updateCanvasTransform();
    });

    document.getElementById('zoomIn').onclick = () => { canvasScale = Math.min(3, canvasScale * 1.2); updateCanvasTransform(); };
    document.getElementById('zoomOut').onclick = () => { canvasScale = Math.max(0.3, canvasScale / 1.2); updateCanvasTransform(); };
    document.getElementById('zoomReset').onclick = () => { canvasScale = 0.8; canvasX = 50; canvasY = 20; updateCanvasTransform(); };

    // Neighbors
    function getNeighbors(pieceId) {
      const p = currentGame.pieces.find(x => x.id === pieceId);
      const { correctRow: row, correctCol: col } = p;
      const { cols, rows } = currentGame.gridSize;
      const n = [];
      if (row > 0) n.push({ id: (row-1)*cols+col, dx: 0, dy: -pieceHeight });
      if (row < rows-1) n.push({ id: (row+1)*cols+col, dx: 0, dy: pieceHeight });
      if (col > 0) n.push({ id: row*cols+(col-1), dx: -pieceWidth, dy: 0 });
      if (col < cols-1) n.push({ id: row*cols+(col+1), dx: pieceWidth, dy: 0 });
      return n;
    }

    // Piece drag
    function onPieceMouseDown(e) {
      e.stopPropagation();
      const pieceId = parseInt(e.target.dataset.pieceId);
      const piece = currentGame.pieces.find(p => p.id === pieceId);
      if (piece.isPlaced || (piece.lockedBy && piece.lockedBy !== myPlayerId)) return;

      draggedPiece = piece;
      draggedGroup = pieceToPieceGroup.get(pieceId) || null;
      
      const el = pieceElements.get(pieceId);
      const rect = el.getBoundingClientRect();
      dragOffsetX = (e.clientX - rect.left) / canvasScale;
      dragOffsetY = (e.clientY - rect.top) / canvasScale;

      if (draggedGroup) pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.add('dragging'));
      else el.classList.add('dragging');

      socket.emit('piece:grab', { pieceId, groupId: draggedGroup });
      document.addEventListener('mousemove', onPieceMouseMove);
      document.addEventListener('mouseup', onPieceMouseUp);
    }

    function onPieceMouseMove(e) {
      if (!draggedPiece) return;
      const rect = puzzleCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / canvasScale - dragOffsetX + tabSize;
      const y = (e.clientY - rect.top) / canvasScale - dragOffsetY + tabSize;
      const dx = x - draggedPiece.currentX, dy = y - draggedPiece.currentY;

      if (draggedGroup) {
        const gd = [];
        pieceGroups.get(draggedGroup).forEach(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX += dx; p.currentY += dy;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; }
          gd.push({ id: pid, x: p.currentX, y: p.currentY });
        });
        socket.emit('piece:move', { pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY, groupId: draggedGroup, groupPieces: gd });
      } else {
        draggedPiece.currentX = x; draggedPiece.currentY = y;
        const el = pieceElements.get(draggedPiece.id);
        if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        socket.emit('piece:move', { pieceId: draggedPiece.id, x, y });
      }
    }

    function onPieceMouseUp() {
      if (!draggedPiece) return;
      
      if (draggedGroup) pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.remove('dragging'));
      else pieceElements.get(draggedPiece.id)?.classList.remove('dragging');

      const boardLeft = 50, boardTop = 50;
      const threshold = Math.min(pieceWidth, pieceHeight) * 0.35;
      let placed = false, newGroup = null, groupPiecesData = null;

      const piecesToCheck = draggedGroup ? Array.from(pieceGroups.get(draggedGroup)) : [draggedPiece.id];
      let allCanPlace = piecesToCheck.every(pid => {
        const p = currentGame.pieces.find(x => x.id === pid);
        const cx = boardLeft + p.correctCol * pieceWidth, cy = boardTop + p.correctRow * pieceHeight;
        return Math.abs(p.currentX - cx) < threshold && Math.abs(p.currentY - cy) < threshold;
      });

      if (allCanPlace) {
        placed = true;
        groupPiecesData = piecesToCheck.map(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX = boardLeft + p.correctCol * pieceWidth;
          p.currentY = boardTop + p.correctRow * pieceHeight;
          p.isPlaced = true;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; el.classList.add('placed'); }
          return { id: pid, x: p.currentX, y: p.currentY, placed: true };
        });
      } else {
        const snapThreshold = Math.min(pieceWidth, pieceHeight) * 0.3;
        
        for (const pid of piecesToCheck) {
          const p = currentGame.pieces.find(x => x.id === pid);
          for (const n of getNeighbors(pid)) {
            if (piecesToCheck.includes(n.id)) continue;
            const np = currentGame.pieces.find(x => x.id === n.id);
            if (!np || np.isPlaced) continue;
            
            const expectedX = np.currentX - n.dx, expectedY = np.currentY - n.dy;
            if (Math.abs(p.currentX - expectedX) < snapThreshold && Math.abs(p.currentY - expectedY) < snapThreshold) {
              const ox = expectedX - p.currentX, oy = expectedY - p.currentY;
              groupPiecesData = piecesToCheck.map(gpid => {
                const gp = currentGame.pieces.find(x => x.id === gpid);
                gp.currentX += ox; gp.currentY += oy;
                const el = pieceElements.get(gpid);
                if (el) { el.style.left = (gp.currentX - tabSize) + 'px'; el.style.top = (gp.currentY - tabSize) + 'px'; }
                return { id: gpid, x: gp.currentX, y: gp.currentY, placed: false };
              });

              const ngid = pieceToPieceGroup.get(n.id);
              if (draggedGroup && ngid) {
                const merged = new Set([...pieceGroups.get(draggedGroup), ...pieceGroups.get(ngid)]);
                pieceGroups.set(draggedGroup, merged);
                pieceGroups.delete(ngid);
                merged.forEach(id => pieceToPieceGroup.set(id, draggedGroup));
                newGroup = { pieceIds: Array.from(merged) };
              } else if (draggedGroup) {
                pieceGroups.get(draggedGroup).add(n.id);
                pieceToPieceGroup.set(n.id, draggedGroup);
                newGroup = { pieceIds: Array.from(pieceGroups.get(draggedGroup)) };
              } else if (ngid) {
                pieceGroups.get(ngid).add(draggedPiece.id);
                pieceToPieceGroup.set(draggedPiece.id, ngid);
                newGroup = { pieceIds: Array.from(pieceGroups.get(ngid)) };
              } else {
                const gid = nextGroupId++;
                pieceGroups.set(gid, new Set([draggedPiece.id, n.id]));
                pieceToPieceGroup.set(draggedPiece.id, gid);
                pieceToPieceGroup.set(n.id, gid);
                newGroup = { pieceIds: [draggedPiece.id, n.id] };
              }
              showToast('Pieces connected!');
              break;
            }
          }
          if (groupPiecesData) break;
        }
      }

      if (!groupPiecesData && draggedGroup) {
        groupPiecesData = Array.from(pieceGroups.get(draggedGroup)).map(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          return { id: pid, x: p.currentX, y: p.currentY, placed: p.isPlaced };
        });
      }

      socket.emit('piece:release', {
        pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY,
        placed, groupId: draggedGroup, groupPieces: groupPiecesData, newGroup
      });

      draggedPiece = null; draggedGroup = null;
      document.removeEventListener('mousemove', onPieceMouseMove);
      document.removeEventListener('mouseup', onPieceMouseUp);
    }

    // Touch
    function onPieceTouchStart(e) {
      e.preventDefault();
      const t = e.touches[0];
      const pieceId = parseInt(e.target.dataset.pieceId);
      const piece = currentGame.pieces.find(p => p.id === pieceId);
      if (piece.isPlaced || (piece.lockedBy && piece.lockedBy !== myPlayerId)) return;

      draggedPiece = piece;
      draggedGroup = pieceToPieceGroup.get(pieceId) || null;
      const el = pieceElements.get(pieceId);
      const rect = el.getBoundingClientRect();
      dragOffsetX = (t.clientX - rect.left) / canvasScale;
      dragOffsetY = (t.clientY - rect.top) / canvasScale;

      if (draggedGroup) pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.add('dragging'));
      else el.classList.add('dragging');

      socket.emit('piece:grab', { pieceId, groupId: draggedGroup });
      document.addEventListener('touchmove', onPieceTouchMove, { passive: false });
      document.addEventListener('touchend', onPieceTouchEnd);
    }

    function onPieceTouchMove(e) {
      e.preventDefault();
      if (!draggedPiece) return;
      const t = e.touches[0];
      const rect = puzzleCanvas.getBoundingClientRect();
      const x = (t.clientX - rect.left) / canvasScale - dragOffsetX + tabSize;
      const y = (t.clientY - rect.top) / canvasScale - dragOffsetY + tabSize;
      const dx = x - draggedPiece.currentX, dy = y - draggedPiece.currentY;

      if (draggedGroup) {
        const gd = [];
        pieceGroups.get(draggedGroup).forEach(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX += dx; p.currentY += dy;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; }
          gd.push({ id: pid, x: p.currentX, y: p.currentY });
        });
        socket.emit('piece:move', { pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY, groupId: draggedGroup, groupPieces: gd });
      } else {
        draggedPiece.currentX = x; draggedPiece.currentY = y;
        const el = pieceElements.get(draggedPiece.id);
        if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        socket.emit('piece:move', { pieceId: draggedPiece.id, x, y });
      }
    }

    function onPieceTouchEnd() {
      onPieceMouseUp();
      document.removeEventListener('touchmove', onPieceTouchMove);
      document.removeEventListener('touchend', onPieceTouchEnd);
    }

    // API
    async function createNewGame(name, pName, imageFile, pieceCount) {
      const fd = new FormData();
      fd.append('gameName', name);
      fd.append('pieceCount', pieceCount);
      fd.append('image', imageFile);
      const res = await fetch('/api/games', { method: 'POST', body: fd });
      if (!res.ok) throw new Error('Failed');
      const data = await res.json();
      connectSocket();
      setTimeout(() => socket.emit('game:join', { gameId: data.gameId, playerName: pName }), 500);
    }

    async function joinGame(gameId, pName) {
      if (!socket) connectSocket();
      setTimeout(() => socket.emit('game:join', { gameId: gameId.toUpperCase(), playerName: pName }), 500);
    }

    // UI Events
    document.getElementById('btnNewGame').onclick = () => { document.getElementById('playerName').value = playerName; openModal('newGameModal'); };
    document.getElementById('pieceSlider').oninput = (e) => document.getElementById('pieceCountDisplay').textContent = e.target.value + ' pieces';
    document.getElementById('imageUpload').onchange = (e) => {
      if (e.target.files[0]) { const p = document.getElementById('imagePreview'); p.src = URL.createObjectURL(e.target.files[0]); p.style.display = 'block'; }
    };
    document.getElementById('cancelNewGame').onclick = () => closeModal('newGameModal');
    document.getElementById('createGame').onclick = async () => {
      const name = document.getElementById('gameName').value || 'Inferno Puzzle';
      const pName = document.getElementById('playerName').value || 'Player';
      const imageFile = document.getElementById('imageUpload').files[0];
      if (!imageFile) { showToast('Select an image!'); return; }
      playerName = pName; localStorage.setItem('playerName', playerName);
      closeModal('newGameModal'); showToast('Creating...');
      try { await createNewGame(name, pName, imageFile, document.getElementById('pieceSlider').value); }
      catch { showToast('Failed'); }
    };

    document.getElementById('btnLoadGame').onclick = async () => {
      document.getElementById('loadPlayerName').value = playerName;
      openModal('loadGameModal');
      try {
        const games = await (await fetch('/api/games')).json();
        const list = document.getElementById('savedGamesList');
        if (!games.length) { list.innerHTML = '<div class="no-games">No saved games</div>'; return; }
        list.innerHTML = games.map(g => `<div class="saved-game-item" data-game-id="${g.id}"><img class="saved-game-thumb" src="${g.imageUrl}"><div class="saved-game-info"><div class="saved-game-name">${g.name}</div><div class="saved-game-meta">${g.totalPieces} pcs ‚Ä¢ ${g.id}</div></div><div class="saved-game-progress">${g.progress}%</div></div>`).join('');
        list.querySelectorAll('.saved-game-item').forEach(item => {
          item.onclick = () => {
            playerName = document.getElementById('loadPlayerName').value || 'Player';
            localStorage.setItem('playerName', playerName);
            closeModal('loadGameModal');
            joinGame(item.dataset.gameId, playerName);
          };
        });
      } catch { document.getElementById('savedGamesList').innerHTML = '<div class="no-games">Failed</div>'; }
    };
    document.getElementById('cancelLoadGame').onclick = () => closeModal('loadGameModal');

    let pendingJoinCode = '';
    document.getElementById('btnJoinGame').onclick = () => {
      const code = document.getElementById('joinCodeInput').value.trim();
      if (!code) { showToast('Enter a code!'); return; }
      pendingJoinCode = code;
      document.getElementById('joinPlayerName').value = playerName;
      openModal('joinNameModal');
    };
    document.getElementById('joinCodeInput').onkeypress = (e) => { if (e.key === 'Enter') document.getElementById('btnJoinGame').click(); };
    document.getElementById('cancelJoin').onclick = () => closeModal('joinNameModal');
    document.getElementById('confirmJoin').onclick = () => {
      playerName = document.getElementById('joinPlayerName').value || 'Player';
      localStorage.setItem('playerName', playerName);
      closeModal('joinNameModal');
      joinGame(pendingJoinCode, playerName);
    };

    document.getElementById('btnUpdateImage').onclick = () => openModal('updateImageModal');
    document.getElementById('newImageUpload').onchange = (e) => {
      if (e.target.files[0]) { const p = document.getElementById('newImagePreview'); p.src = URL.createObjectURL(e.target.files[0]); p.style.display = 'block'; }
    };
    document.getElementById('cancelUpdateImage').onclick = () => closeModal('updateImageModal');
    document.getElementById('confirmUpdateImage').onclick = async () => {
      const imageFile = document.getElementById('newImageUpload').files[0];
      if (!imageFile) { showToast('Select an image!'); return; }
      closeModal('updateImageModal'); showToast('Updating...');
      const fd = new FormData(); fd.append('image', imageFile);
      try { await fetch(`/api/games/${currentGame.id}/image`, { method: 'POST', body: fd }); }
      catch { showToast('Failed'); }
    };

    document.getElementById('btnShare').onclick = () => {
      if (currentGame) { navigator.clipboard.writeText(`${location.origin}?game=${currentGame.id}`); showToast('Link copied!'); }
    };

    document.getElementById('btnHome').onclick = () => {
      if (socket) { socket.disconnect(); socket = null; }
      currentGame = null; pieceElements.clear(); pieceGroups.clear(); pieceToPieceGroup.clear(); nextGroupId = 1;
      remoteCursors.forEach(c => c.remove()); remoteCursors.clear();
      edgeCache = null;
      puzzleCanvas.innerHTML = '<div class="puzzle-board" id="puzzleBoard"></div>';
      document.getElementById('mainMenu').classList.remove('hidden');
      puzzleContainer.classList.remove('active');
      document.getElementById('gameInfo').classList.remove('active');
      document.getElementById('playersPanel').classList.remove('active');
      document.getElementById('zoomControls').classList.remove('active');
      document.getElementById('minimap').classList.remove('active');
      document.getElementById('btnHome').style.display = 'none';
      document.getElementById('btnUpdateImage').style.display = 'none';
      document.getElementById('btnShare').style.display = 'none';
    };

    document.getElementById('victoryHome').onclick = () => {
      document.getElementById('victoryOverlay').classList.remove('active');
      document.getElementById('btnHome').click();
    };

    // URL game code
    const urlGame = new URLSearchParams(location.search).get('game');
    if (urlGame) { document.getElementById('joinCodeInput').value = urlGame; document.getElementById('btnJoinGame').click(); }
  </script>
</body>
</html>
