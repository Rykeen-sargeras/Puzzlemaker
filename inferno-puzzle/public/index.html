<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üî• Inferno Puzzle - Collaborative Puzzle Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --fire-orange: #FF6B35;
      --fire-yellow: #F7C531;
      --fire-red: #E83F6F;
      --ember: #FF4500;
      --coal: #1a1a1a;
      --ash: #2d2d2d;
      --smoke: #3d3d3d;
      --charcoal: #252525;
    }
    html, body { height: 100%; overflow: hidden; font-family: 'Rajdhani', sans-serif; background: var(--coal); color: #fff; }
    body {
      background: 
        radial-gradient(ellipse at bottom, rgba(255, 69, 0, 0.15) 0%, transparent 60%),
        radial-gradient(ellipse at top right, rgba(247, 197, 49, 0.08) 0%, transparent 40%),
        linear-gradient(180deg, #0d0d0d 0%, #1a1a1a 50%, #1f1510 100%);
    }
    .fire-particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; overflow: hidden; }
    .ember-particle {
      position: absolute; width: 4px; height: 4px; background: var(--fire-orange); border-radius: 50%;
      filter: blur(1px); animation: float-up 4s ease-in infinite;
      box-shadow: 0 0 6px var(--fire-orange), 0 0 12px var(--fire-yellow);
    }
    @keyframes float-up {
      0% { transform: translateY(100vh) scale(1); opacity: 0; }
      10% { opacity: 1; } 90% { opacity: 1; }
      100% { transform: translateY(-20vh) scale(0); opacity: 0; }
    }
    .header {
      position: fixed; top: 0; left: 0; right: 0; height: 60px;
      background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
      backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255, 107, 53, 0.3);
      display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 1000;
    }
    .logo {
      font-family: 'Cinzel', serif; font-size: 1.8rem; font-weight: 900;
      background: linear-gradient(135deg, var(--fire-yellow) 0%, var(--fire-orange) 50%, var(--fire-red) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 2px;
    }
    .logo::before { content: 'üî• '; -webkit-text-fill-color: initial; }
    .header-controls { display: flex; gap: 10px; align-items: center; }
    .btn {
      font-family: 'Rajdhani', sans-serif; font-weight: 600; font-size: 0.9rem;
      padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;
      transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;
    }
    .btn-fire {
      background: linear-gradient(135deg, var(--fire-orange) 0%, var(--fire-red) 100%);
      color: #fff; box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
    }
    .btn-fire:hover { transform: translateY(-2px); box-shadow: 0 6px 25px rgba(255, 107, 53, 0.6); }
    .btn-ghost { background: transparent; color: var(--fire-orange); border: 1px solid var(--fire-orange); }
    .btn-ghost:hover { background: rgba(255, 107, 53, 0.1); }
    .game-info {
      position: fixed; top: 60px; left: 0; right: 0; height: 50px;
      background: rgba(0,0,0,0.6); border-bottom: 1px solid rgba(255, 107, 53, 0.2);
      display: none; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 999;
    }
    .game-info.active { display: flex; }
    .game-title { font-family: 'Cinzel', serif; font-size: 1.1rem; color: var(--fire-yellow); }
    .game-code {
      font-family: monospace; font-size: 1.2rem; background: var(--ash);
      padding: 4px 12px; border-radius: 4px; color: var(--fire-orange);
      border: 1px solid rgba(255, 107, 53, 0.3); letter-spacing: 2px;
    }
    .progress-container { display: flex; align-items: center; gap: 10px; flex: 1; max-width: 300px; margin: 0 20px; }
    .progress-bar { flex: 1; height: 8px; background: var(--ash); border-radius: 4px; overflow: hidden; }
    .progress-fill {
      height: 100%; background: linear-gradient(90deg, var(--fire-orange), var(--fire-yellow));
      border-radius: 4px; transition: width 0.5s ease; box-shadow: 0 0 10px var(--fire-orange);
    }
    .progress-text { font-weight: 700; color: var(--fire-yellow); min-width: 50px; text-align: right; }
    .players-panel {
      position: fixed; top: 120px; right: 10px; width: 200px; background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255, 107, 53, 0.3); border-radius: 8px; padding: 15px; z-index: 998; display: none;
    }
    .players-panel.active { display: block; }
    .players-title { font-family: 'Cinzel', serif; font-size: 0.9rem; color: var(--fire-orange); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .player-item { display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 0.85rem; }
    .player-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
    .player-name { flex: 1; }
    .player-you { color: var(--fire-yellow); font-weight: 600; }
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex;
      align-items: center; justify-content: center; z-index: 2000;
      opacity: 0; visibility: hidden; transition: all 0.3s ease;
    }
    .modal-overlay.active { opacity: 1; visibility: visible; }
    .modal {
      background: linear-gradient(180deg, var(--charcoal) 0%, var(--coal) 100%);
      border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 12px; padding: 30px;
      max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
      transform: scale(0.9); transition: transform 0.3s ease; box-shadow: 0 0 60px rgba(255, 107, 53, 0.2);
    }
    .modal-overlay.active .modal { transform: scale(1); }
    .modal-title {
      font-family: 'Cinzel', serif; font-size: 1.5rem; color: var(--fire-orange);
      margin-bottom: 20px; text-align: center; text-transform: uppercase; letter-spacing: 2px;
    }
    .form-group { margin-bottom: 20px; }
    .form-label { display: block; font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px; }
    .form-input {
      width: 100%; padding: 12px; background: var(--ash); border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 6px; color: #fff; font-family: 'Rajdhani', sans-serif; font-size: 1rem; transition: all 0.3s ease;
    }
    .form-input:focus { outline: none; border-color: var(--fire-orange); box-shadow: 0 0 15px rgba(255, 107, 53, 0.3); }
    .form-input::file-selector-button {
      background: var(--fire-orange); color: #fff; border: none; padding: 8px 16px;
      border-radius: 4px; cursor: pointer; font-family: 'Rajdhani', sans-serif; font-weight: 600; margin-right: 10px;
    }
    .piece-slider { -webkit-appearance: none; width: 100%; height: 8px; background: var(--ash); border-radius: 4px; outline: none; }
    .piece-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px;
      background: linear-gradient(135deg, var(--fire-orange), var(--fire-red));
      border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--fire-orange);
    }
    .piece-count-display { text-align: center; font-size: 2rem; font-weight: 700; color: var(--fire-yellow); margin: 10px 0; }
    .image-preview { width: 100%; max-height: 150px; object-fit: contain; border-radius: 6px; margin-top: 10px; display: none; }
    .btn-row { display: flex; gap: 10px; margin-top: 20px; }
    .btn-row .btn { flex: 1; }
    .saved-games-list { max-height: 300px; overflow-y: auto; }
    .saved-game-item {
      display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--ash);
      border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s ease; border: 1px solid transparent;
    }
    .saved-game-item:hover { border-color: var(--fire-orange); transform: translateX(5px); }
    .saved-game-thumb { width: 60px; height: 45px; object-fit: cover; border-radius: 4px; }
    .saved-game-info { flex: 1; }
    .saved-game-name { font-weight: 600; color: var(--fire-yellow); }
    .saved-game-meta { font-size: 0.8rem; color: rgba(255,255,255,0.5); }
    .saved-game-progress { font-weight: 700; color: var(--fire-orange); }
    .no-games { text-align: center; color: rgba(255,255,255,0.5); padding: 30px; }
    .main-menu { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
    .main-menu.hidden { display: none; }
    .menu-logo {
      font-family: 'Cinzel', serif; font-size: 4rem; font-weight: 900;
      background: linear-gradient(135deg, var(--fire-yellow) 0%, var(--fire-orange) 50%, var(--fire-red) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px;
      animation: pulse-glow 2s ease-in-out infinite;
    }
    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 107, 53, 0.6)); }
      50% { filter: drop-shadow(0 0 40px rgba(255, 107, 53, 0.9)); }
    }
    .menu-subtitle { font-size: 1.2rem; color: rgba(255,255,255,0.6); margin-bottom: 50px; letter-spacing: 4px; text-transform: uppercase; }
    .menu-buttons { display: flex; flex-direction: column; gap: 15px; width: 280px; }
    .menu-btn { padding: 16px 32px; font-size: 1.1rem; border-radius: 8px; }
    .join-input-group { display: flex; gap: 10px; margin-top: 15px; }
    .join-input {
      flex: 1; padding: 12px; background: var(--ash); border: 1px solid rgba(255, 107, 53, 0.3);
      border-radius: 6px; color: #fff; font-family: monospace; font-size: 1.1rem;
      text-transform: uppercase; letter-spacing: 2px; text-align: center;
    }
    .join-input:focus { outline: none; border-color: var(--fire-orange); }
    .puzzle-container { position: fixed; inset: 0; top: 110px; display: none; overflow: hidden; cursor: grab; }
    .puzzle-container.active { display: block; }
    .puzzle-canvas { position: absolute; transform-origin: 0 0; }
    .puzzle-board {
      position: absolute; left: 50px; top: 50px;
      border: 3px solid rgba(255, 107, 53, 0.5);
      background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3));
      box-shadow: 0 0 50px rgba(255, 107, 53, 0.2), inset 0 0 100px rgba(0,0,0,0.5);
      border-radius: 4px;
    }
    .puzzle-piece {
      position: absolute; cursor: grab; transition: filter 0.2s ease;
      filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.5));
    }
    .puzzle-piece:hover { z-index: 100; filter: drop-shadow(0 0 15px rgba(255, 107, 53, 0.8)) drop-shadow(2px 2px 3px rgba(0,0,0,0.5)); }
    .puzzle-piece.dragging { cursor: grabbing; z-index: 1000; filter: drop-shadow(0 0 20px rgba(255, 107, 53, 1)) drop-shadow(5px 10px 20px rgba(0,0,0,0.7)); }
    .puzzle-piece.placed { cursor: default; filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3)); }
    .puzzle-piece.locked { filter: drop-shadow(0 0 10px var(--lock-color)) drop-shadow(2px 2px 3px rgba(0,0,0,0.5)); }
    .remote-cursor { position: absolute; pointer-events: none; z-index: 2000; transition: transform 0.1s linear; }
    .cursor-dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 10px currentColor; }
    .cursor-name { position: absolute; left: 16px; top: -4px; font-size: 0.75rem; background: currentColor; color: #000; padding: 2px 6px; border-radius: 4px; white-space: nowrap; font-weight: 600; }
    .zoom-controls { position: fixed; bottom: 20px; right: 20px; display: none; flex-direction: column; gap: 8px; z-index: 999; }
    .zoom-controls.active { display: flex; }
    .zoom-btn { width: 40px; height: 40px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 8px; color: var(--fire-orange); font-size: 1.4rem; cursor: pointer; transition: all 0.3s ease; }
    .zoom-btn:hover { background: var(--fire-orange); color: #fff; }
    .victory-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex;
      flex-direction: column; align-items: center; justify-content: center;
      z-index: 3000; opacity: 0; visibility: hidden; transition: all 0.5s ease;
    }
    .victory-overlay.active { opacity: 1; visibility: visible; }
    .victory-title {
      font-family: 'Cinzel', serif; font-size: 4rem;
      background: linear-gradient(135deg, var(--fire-yellow), var(--fire-orange), var(--fire-red));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      animation: victory-pulse 1s ease-in-out infinite;
    }
    @keyframes victory-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .victory-subtitle { font-size: 1.5rem; color: rgba(255,255,255,0.7); margin: 20px 0 40px; }
    .minimap { position: fixed; bottom: 20px; left: 20px; width: 150px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 107, 53, 0.4); border-radius: 8px; padding: 8px; display: none; z-index: 999; }
    .minimap.active { display: block; }
    .minimap-image { width: 100%; border-radius: 4px; opacity: 0.8; }
    .minimap-title { font-size: 0.7rem; color: rgba(255,255,255,0.5); text-align: center; margin-top: 4px; text-transform: uppercase; letter-spacing: 1px; }
    .toast-container { position: fixed; top: 120px; left: 50%; transform: translateX(-50%); z-index: 2500; display: flex; flex-direction: column; gap: 10px; }
    .toast { background: rgba(0,0,0,0.9); border: 1px solid var(--fire-orange); padding: 12px 24px; border-radius: 8px; color: #fff; font-weight: 500; animation: toast-in 0.3s ease, toast-out 0.3s ease 2.7s forwards; box-shadow: 0 0 20px rgba(255, 107, 53, 0.4); }
    @keyframes toast-in { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes toast-out { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-20px); } }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: var(--coal); }
    ::-webkit-scrollbar-thumb { background: var(--fire-orange); border-radius: 4px; }
  </style>
</head>
<body>
  <div class="fire-particles" id="fireParticles"></div>
  <header class="header">
    <div class="logo">INFERNO PUZZLE</div>
    <div class="header-controls">
      <button class="btn btn-ghost" id="btnHome" style="display:none">‚Üê Menu</button>
      <button class="btn btn-ghost" id="btnUpdateImage" style="display:none">Update Image</button>
      <button class="btn btn-fire" id="btnShare" style="display:none">Share Code</button>
    </div>
  </header>
  <div class="game-info" id="gameInfo">
    <div class="game-title" id="gameTitle">Loading...</div>
    <div class="progress-container">
      <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
      <span class="progress-text" id="progressText">0%</span>
    </div>
    <div class="game-code" id="gameCodeDisplay">--------</div>
  </div>
  <div class="players-panel" id="playersPanel">
    <div class="players-title">üî• Players Online</div>
    <div id="playersList"></div>
  </div>
  <div class="main-menu" id="mainMenu">
    <div class="menu-logo">üî• INFERNO</div>
    <div class="menu-subtitle">Collaborative Puzzle</div>
    <div class="menu-buttons">
      <button class="btn btn-fire menu-btn" id="btnNewGame">üéÆ New Game</button>
      <button class="btn btn-ghost menu-btn" id="btnLoadGame">üìÇ Load Game</button>
      <div class="join-input-group">
        <input type="text" class="join-input" id="joinCodeInput" placeholder="CODE" maxlength="8">
        <button class="btn btn-fire" id="btnJoinGame">Join</button>
      </div>
    </div>
  </div>
  <div class="puzzle-container" id="puzzleContainer">
    <div class="puzzle-canvas" id="puzzleCanvas">
      <div class="puzzle-board" id="puzzleBoard"></div>
    </div>
  </div>
  <div class="zoom-controls" id="zoomControls">
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomOut">‚àí</button>
    <button class="zoom-btn" id="zoomReset">‚ü≤</button>
  </div>
  <div class="minimap" id="minimap">
    <img class="minimap-image" id="minimapImage" src="" alt="Reference">
    <div class="minimap-title">Reference</div>
  </div>
  <div class="modal-overlay" id="newGameModal">
    <div class="modal">
      <h2 class="modal-title">üî• Create New Puzzle</h2>
      <div class="form-group"><label class="form-label">Puzzle Name</label><input type="text" class="form-input" id="gameName" placeholder="My Awesome Puzzle"></div>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="playerName" placeholder="Enter your name"></div>
      <div class="form-group"><label class="form-label">Upload Image</label><input type="file" class="form-input" id="imageUpload" accept="image/*"><img class="image-preview" id="imagePreview"></div>
      <div class="form-group">
        <label class="form-label">Number of Pieces</label>
        <input type="range" class="piece-slider" id="pieceSlider" min="100" max="1000" value="400" step="50">
        <div class="piece-count-display" id="pieceCountDisplay">400 pieces</div>
      </div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelNewGame">Cancel</button><button class="btn btn-fire" id="createGame">Create Puzzle</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="loadGameModal">
    <div class="modal">
      <h2 class="modal-title">üìÇ Load Saved Game</h2>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="loadPlayerName" placeholder="Enter your name"></div>
      <div class="saved-games-list" id="savedGamesList"><div class="no-games">Loading saved games...</div></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelLoadGame">Cancel</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="updateImageModal">
    <div class="modal">
      <h2 class="modal-title">üñºÔ∏è Update Puzzle Image</h2>
      <p style="color: rgba(255,255,255,0.6); margin-bottom: 20px; text-align: center;">Warning: This will reset all puzzle progress!</p>
      <div class="form-group"><label class="form-label">New Image</label><input type="file" class="form-input" id="newImageUpload" accept="image/*"><img class="image-preview" id="newImagePreview"></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelUpdateImage">Cancel</button><button class="btn btn-fire" id="confirmUpdateImage">Update & Reset</button></div>
    </div>
  </div>
  <div class="modal-overlay" id="joinNameModal">
    <div class="modal">
      <h2 class="modal-title">üî• Join Puzzle</h2>
      <div class="form-group"><label class="form-label">Your Name</label><input type="text" class="form-input" id="joinPlayerName" placeholder="Enter your name"></div>
      <div class="btn-row"><button class="btn btn-ghost" id="cancelJoin">Cancel</button><button class="btn btn-fire" id="confirmJoin">Join Game</button></div>
    </div>
  </div>
  <div class="victory-overlay" id="victoryOverlay">
    <div class="victory-title">üî• PUZZLE COMPLETE! üî•</div>
    <div class="victory-subtitle">Congratulations to all players!</div>
    <button class="btn btn-fire menu-btn" id="victoryHome">Back to Menu</button>
  </div>
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // Fire particles
    (function() {
      const container = document.getElementById('fireParticles');
      for (let i = 0; i < 30; i++) {
        const p = document.createElement('div');
        p.className = 'ember-particle';
        p.style.left = Math.random() * 100 + '%';
        p.style.animationDelay = Math.random() * 4 + 's';
        p.style.animationDuration = (3 + Math.random() * 3) + 's';
        container.appendChild(p);
      }
    })();

    // Global state
    let socket = null, currentGame = null, myPlayerId = null;
    let playerName = localStorage.getItem('playerName') || '';
    let pieceElements = new Map(), remoteCursors = new Map(), puzzleImage = null;
    let pieceShapes = new Map(), pieceGroups = new Map(), pieceToPieceGroup = new Map();
    let nextGroupId = 1, pieceWidth = 0, pieceHeight = 0, tabSize = 0;
    let canvasScale = 1, canvasX = 0, canvasY = 0, isDraggingCanvas = false, lastMouseX = 0, lastMouseY = 0;
    let draggedPiece = null, draggedGroup = null, dragOffsetX = 0, dragOffsetY = 0;

    const puzzleContainer = document.getElementById('puzzleContainer');
    const puzzleCanvas = document.getElementById('puzzleCanvas');
    const puzzleBoard = document.getElementById('puzzleBoard');

    // Seeded random for consistent jigsaw shapes across clients
    function createRandom(seed) {
      return function() {
        seed = (seed * 1103515245 + 12345) & 0x7fffffff;
        return seed / 0x7fffffff;
      };
    }

    // Generate truly random piece shapes with varied tabs
    function generatePieceShapes(rows, cols, seed) {
      const shapes = new Map();
      const rand = createRandom(seed);
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const id = row * cols + col;
          
          // Each edge gets random parameters for unique shapes
          const shape = {
            top: row === 0 ? null : {
              dir: -shapes.get((row - 1) * cols + col).bottom.dir,
              pos: shapes.get((row - 1) * cols + col).bottom.pos,
              size: shapes.get((row - 1) * cols + col).bottom.size,
              width: shapes.get((row - 1) * cols + col).bottom.width,
              curve: shapes.get((row - 1) * cols + col).bottom.curve
            },
            right: col === cols - 1 ? null : {
              dir: rand() > 0.5 ? 1 : -1,        // Tab direction (in/out)
              pos: 0.35 + rand() * 0.3,          // Position along edge (0.35-0.65)
              size: 0.18 + rand() * 0.14,        // Tab size (0.18-0.32)
              width: 0.25 + rand() * 0.2,        // Tab width (0.25-0.45)
              curve: 0.4 + rand() * 0.4          // Curve intensity (0.4-0.8)
            },
            bottom: row === rows - 1 ? null : {
              dir: rand() > 0.5 ? 1 : -1,
              pos: 0.35 + rand() * 0.3,
              size: 0.18 + rand() * 0.14,
              width: 0.25 + rand() * 0.2,
              curve: 0.4 + rand() * 0.4
            },
            left: col === 0 ? null : {
              dir: -shapes.get(row * cols + (col - 1)).right.dir,
              pos: shapes.get(row * cols + (col - 1)).right.pos,
              size: shapes.get(row * cols + (col - 1)).right.size,
              width: shapes.get(row * cols + (col - 1)).right.width,
              curve: shapes.get(row * cols + (col - 1)).right.curve
            }
          };
          shapes.set(id, shape);
        }
      }
      return shapes;
    }

    // Draw a single edge with tab/blank
    function drawEdge(ctx, startX, startY, endX, endY, tabInfo, isHorizontal) {
      if (!tabInfo) {
        ctx.lineTo(endX, endY);
        return;
      }
      
      const { dir, pos, size, width, curve } = tabInfo;
      const len = isHorizontal ? (endX - startX) : (endY - startY);
      const tabLen = Math.abs(len) * size;
      const tabWidth = Math.abs(len) * width;
      
      if (isHorizontal) {
        const tabX = startX + len * pos;
        const tabY = startY + dir * tabLen;
        const halfWidth = tabWidth / 2;
        
        // Line to tab start
        ctx.lineTo(tabX - halfWidth, startY);
        
        // Tab curve using bezier
        const cp1x = tabX - halfWidth * curve;
        const cp1y = startY + dir * tabLen * 0.2;
        const cp2x = tabX - halfWidth * 0.8;
        const cp2y = tabY;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tabX, tabY);
        
        const cp3x = tabX + halfWidth * 0.8;
        const cp3y = tabY;
        const cp4x = tabX + halfWidth * curve;
        const cp4y = startY + dir * tabLen * 0.2;
        ctx.bezierCurveTo(cp3x, cp3y, cp4x, cp4y, tabX + halfWidth, startY);
        
        // Line to end
        ctx.lineTo(endX, endY);
      } else {
        const tabY = startY + len * pos;
        const tabX = startX + dir * tabLen;
        const halfWidth = tabWidth / 2;
        
        ctx.lineTo(startX, tabY - halfWidth);
        
        const cp1x = startX + dir * tabLen * 0.2;
        const cp1y = tabY - halfWidth * curve;
        const cp2x = tabX;
        const cp2y = tabY - halfWidth * 0.8;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tabX, tabY);
        
        const cp3x = tabX;
        const cp3y = tabY + halfWidth * 0.8;
        const cp4x = startX + dir * tabLen * 0.2;
        const cp4y = tabY + halfWidth * curve;
        ctx.bezierCurveTo(cp3x, cp3y, cp4x, cp4y, startX, tabY + halfWidth);
        
        ctx.lineTo(endX, endY);
      }
    }

    // Create jigsaw piece path
    function createPiecePath(ctx, shape, w, h) {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      
      // Top edge (left to right)
      drawEdge(ctx, 0, 0, w, 0, shape.top, true);
      
      // Right edge (top to bottom)  
      drawEdge(ctx, w, 0, w, h, shape.right, false);
      
      // Bottom edge (right to left) - reverse direction
      if (shape.bottom) {
        const reversed = { ...shape.bottom, dir: -shape.bottom.dir };
        ctx.lineTo(w, h);
        // Draw backwards
        const tempCtx = { pts: [] };
        drawEdgeReverse(ctx, w, h, 0, h, reversed, true);
      } else {
        ctx.lineTo(0, h);
      }
      
      // Left edge (bottom to top) - reverse direction
      if (shape.left) {
        const reversed = { ...shape.left, dir: -shape.left.dir };
        drawEdgeReverse(ctx, 0, h, 0, 0, reversed, false);
      } else {
        ctx.lineTo(0, 0);
      }
      
      ctx.closePath();
    }

    function drawEdgeReverse(ctx, startX, startY, endX, endY, tabInfo, isHorizontal) {
      if (!tabInfo) {
        ctx.lineTo(endX, endY);
        return;
      }
      
      const { dir, pos, size, width, curve } = tabInfo;
      const len = isHorizontal ? (endX - startX) : (endY - startY);
      const tabLen = Math.abs(isHorizontal ? (startX - endX) : (startY - endY)) * size;
      const tabWidth = Math.abs(isHorizontal ? (startX - endX) : (startY - endY)) * width;
      
      if (isHorizontal) {
        const tabX = endX + (startX - endX) * (1 - pos);
        const tabY = startY + dir * tabLen;
        const halfWidth = tabWidth / 2;
        
        ctx.lineTo(tabX + halfWidth, startY);
        
        const cp1x = tabX + halfWidth * curve;
        const cp1y = startY + dir * tabLen * 0.2;
        const cp2x = tabX + halfWidth * 0.8;
        const cp2y = tabY;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tabX, tabY);
        
        const cp3x = tabX - halfWidth * 0.8;
        const cp3y = tabY;
        const cp4x = tabX - halfWidth * curve;
        const cp4y = startY + dir * tabLen * 0.2;
        ctx.bezierCurveTo(cp3x, cp3y, cp4x, cp4y, tabX - halfWidth, startY);
        
        ctx.lineTo(endX, endY);
      } else {
        const tabY = endY + (startY - endY) * (1 - pos);
        const tabX = startX + dir * tabLen;
        const halfWidth = tabWidth / 2;
        
        ctx.lineTo(startX, tabY + halfWidth);
        
        const cp1x = startX + dir * tabLen * 0.2;
        const cp1y = tabY + halfWidth * curve;
        const cp2x = tabX;
        const cp2y = tabY + halfWidth * 0.8;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tabX, tabY);
        
        const cp3x = tabX;
        const cp3y = tabY - halfWidth * 0.8;
        const cp4x = startX + dir * tabLen * 0.2;
        const cp4y = tabY - halfWidth * curve;
        ctx.bezierCurveTo(cp3x, cp3y, cp4x, cp4y, startX, tabY - halfWidth);
        
        ctx.lineTo(endX, endY);
      }
    }

    function showToast(msg) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = msg;
      document.getElementById('toastContainer').appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function openModal(id) { document.getElementById(id).classList.add('active'); }
    function closeModal(id) { document.getElementById(id).classList.remove('active'); }

    // Socket connection
    function connectSocket() {
      socket = io();
      
      socket.on('game:state', (game) => {
        currentGame = game;
        myPlayerId = game.yourId;
        pieceGroups.clear(); pieceToPieceGroup.clear();
        if (game.groups) {
          game.groups.forEach((g, i) => {
            const gid = i + 1;
            pieceGroups.set(gid, new Set(g.pieceIds));
            g.pieceIds.forEach(pid => pieceToPieceGroup.set(pid, gid));
          });
          nextGroupId = game.groups.length + 1;
        }
        renderGame();
        showToast('Joined: ' + game.name);
      });

      socket.on('player:joined', (p) => { if (p.id !== myPlayerId) showToast(p.name + ' joined!'); });
      socket.on('player:left', ({ playerId }) => { remoteCursors.get(playerId)?.remove(); remoteCursors.delete(playerId); });
      socket.on('players:update', (players) => { currentGame.players = players; renderPlayers(); });

      socket.on('piece:grabbed', ({ pieceId, playerId }) => {
        const p = currentGame.pieces.find(x => x.id === pieceId);
        if (p) p.lockedBy = playerId;
        updatePieceLock(pieceId, playerId);
      });

      socket.on('piece:moved', ({ pieceId, x, y, groupPieces }) => {
        if (groupPieces) {
          groupPieces.forEach(gp => {
            const p = currentGame.pieces.find(x => x.id === gp.id);
            if (p) { p.currentX = gp.x; p.currentY = gp.y; }
            const el = pieceElements.get(gp.id);
            if (el) { el.style.left = (gp.x - tabSize) + 'px'; el.style.top = (gp.y - tabSize) + 'px'; }
          });
        } else {
          const p = currentGame.pieces.find(x => x.id === pieceId);
          if (p) { p.currentX = x; p.currentY = y; }
          const el = pieceElements.get(pieceId);
          if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        }
      });

      socket.on('piece:released', ({ pieceId, x, y, placed, progress, groupPieces, newGroup }) => {
        const updates = groupPieces || [{ id: pieceId, x, y, placed }];
        updates.forEach(u => {
          const p = currentGame.pieces.find(x => x.id === u.id);
          if (p) { p.currentX = u.x; p.currentY = u.y; p.isPlaced = u.placed; p.lockedBy = null; }
          const el = pieceElements.get(u.id);
          if (el) {
            el.style.left = (u.x - tabSize) + 'px';
            el.style.top = (u.y - tabSize) + 'px';
            el.classList.remove('locked');
            if (u.placed) el.classList.add('placed');
          }
        });
        if (newGroup?.pieceIds) {
          const gid = nextGroupId++;
          pieceGroups.set(gid, new Set(newGroup.pieceIds));
          newGroup.pieceIds.forEach(pid => pieceToPieceGroup.set(pid, gid));
        }
        updateProgress(progress);
      });

      socket.on('cursor:update', ({ playerId, x, y }) => updateRemoteCursor(playerId, x, y));
      socket.on('game:reset', ({ imageUrl, pieces }) => {
        currentGame.imageUrl = imageUrl; currentGame.pieces = pieces;
        pieceGroups.clear(); pieceToPieceGroup.clear(); nextGroupId = 1;
        renderPuzzle();
        document.getElementById('minimapImage').src = imageUrl;
        showToast('Puzzle reset!');
      });
      socket.on('game:complete', () => document.getElementById('victoryOverlay').classList.add('active'));
      socket.on('error', ({ message }) => showToast('Error: ' + message));
    }

    function updateRemoteCursor(playerId, x, y) {
      let cursor = remoteCursors.get(playerId);
      const player = currentGame?.players.find(p => p.id === playerId);
      if (!cursor && player) {
        cursor = document.createElement('div');
        cursor.className = 'remote-cursor';
        cursor.innerHTML = `<div class="cursor-dot" style="background:${player.color};color:${player.color}"></div><div class="cursor-name" style="background:${player.color}">${player.name}</div>`;
        puzzleCanvas.appendChild(cursor);
        remoteCursors.set(playerId, cursor);
      }
      if (cursor) cursor.style.transform = `translate(${x}px,${y}px)`;
    }

    function renderGame() {
      document.getElementById('mainMenu').classList.add('hidden');
      puzzleContainer.classList.add('active');
      document.getElementById('gameInfo').classList.add('active');
      document.getElementById('playersPanel').classList.add('active');
      document.getElementById('zoomControls').classList.add('active');
      document.getElementById('minimap').classList.add('active');
      document.getElementById('btnHome').style.display = 'block';
      document.getElementById('btnUpdateImage').style.display = 'block';
      document.getElementById('btnShare').style.display = 'block';
      document.getElementById('gameTitle').textContent = currentGame.name;
      document.getElementById('gameCodeDisplay').textContent = currentGame.id;
      document.getElementById('minimapImage').src = currentGame.imageUrl;
      updateProgress(currentGame.progress);
      renderPlayers();
      renderPuzzle();
      canvasScale = 0.8; canvasX = 50; canvasY = 20;
      updateCanvasTransform();
    }

    function renderPlayers() {
      document.getElementById('playersList').innerHTML = currentGame.players.map(p =>
        `<div class="player-item"><div class="player-dot" style="background:${p.color}"></div><span class="player-name ${p.id===myPlayerId?'player-you':''}">${p.name}${p.id===myPlayerId?' (You)':''}</span></div>`
      ).join('');
    }

    function renderPuzzle() {
      pieceElements.forEach(el => el.remove());
      pieceElements.clear();
      pieceWidth = 800 / currentGame.gridSize.cols;
      pieceHeight = 600 / currentGame.gridSize.rows;
      tabSize = Math.min(pieceWidth, pieceHeight) * 0.25;
      puzzleBoard.style.width = '800px';
      puzzleBoard.style.height = '600px';
      
      const seed = currentGame.id.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
      pieceShapes = generatePieceShapes(currentGame.gridSize.rows, currentGame.gridSize.cols, seed);
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => { puzzleImage = img; currentGame.pieces.forEach(p => createPieceElement(p)); };
      img.src = currentGame.imageUrl;
    }

    function createPieceElement(piece) {
      const shape = pieceShapes.get(piece.id);
      if (!shape || !puzzleImage) return;
      
      const extW = pieceWidth + tabSize * 2;
      const extH = pieceHeight + tabSize * 2;
      const canvas = document.createElement('canvas');
      canvas.width = extW;
      canvas.height = extH;
      const ctx = canvas.getContext('2d');
      
      ctx.translate(tabSize, tabSize);
      
      // Create clipping path
      createPiecePath(ctx, shape, pieceWidth, pieceHeight);
      ctx.save();
      ctx.clip();
      
      // Draw image portion
      const sx = (piece.correctCol / currentGame.gridSize.cols) * puzzleImage.width;
      const sy = (piece.correctRow / currentGame.gridSize.rows) * puzzleImage.height;
      const sw = puzzleImage.width / currentGame.gridSize.cols;
      const sh = puzzleImage.height / currentGame.gridSize.rows;
      ctx.drawImage(puzzleImage, sx, sy, sw, sh, 0, 0, pieceWidth, pieceHeight);
      ctx.restore();
      
      // Draw border
      createPiecePath(ctx, shape, pieceWidth, pieceHeight);
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Create DOM element
      const el = document.createElement('div');
      el.className = 'puzzle-piece' + (piece.isPlaced ? ' placed' : '');
      el.style.width = extW + 'px';
      el.style.height = extH + 'px';
      el.style.left = (piece.currentX - tabSize) + 'px';
      el.style.top = (piece.currentY - tabSize) + 'px';
      el.style.backgroundImage = `url(${canvas.toDataURL()})`;
      el.style.backgroundSize = 'cover';
      el.dataset.pieceId = piece.id;
      
      if (piece.lockedBy && piece.lockedBy !== myPlayerId) {
        const player = currentGame.players.find(p => p.id === piece.lockedBy);
        if (player) { el.classList.add('locked'); el.style.setProperty('--lock-color', player.color); }
      }
      
      el.addEventListener('mousedown', onPieceMouseDown);
      el.addEventListener('touchstart', onPieceTouchStart, { passive: false });
      puzzleCanvas.appendChild(el);
      pieceElements.set(piece.id, el);
    }

    function updatePieceLock(pieceId, playerId) {
      const el = pieceElements.get(pieceId);
      if (!el) return;
      if (playerId && playerId !== myPlayerId) {
        const player = currentGame.players.find(p => p.id === playerId);
        if (player) { el.classList.add('locked'); el.style.setProperty('--lock-color', player.color); }
      } else el.classList.remove('locked');
    }

    function updateProgress(progress) {
      currentGame.progress = progress;
      document.getElementById('progressFill').style.width = progress + '%';
      document.getElementById('progressText').textContent = progress + '%';
    }

    function updateCanvasTransform() {
      puzzleCanvas.style.transform = `translate(${canvasX}px,${canvasY}px) scale(${canvasScale})`;
    }

    // Canvas pan
    puzzleContainer.addEventListener('mousedown', (e) => {
      if (e.target === puzzleContainer || e.target === puzzleCanvas || e.target === puzzleBoard) {
        isDraggingCanvas = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
        puzzleContainer.style.cursor = 'grabbing';
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDraggingCanvas) {
        canvasX += e.clientX - lastMouseX; canvasY += e.clientY - lastMouseY;
        lastMouseX = e.clientX; lastMouseY = e.clientY;
        updateCanvasTransform();
      }
      if (currentGame && socket) {
        const rect = puzzleCanvas.getBoundingClientRect();
        socket.emit('cursor:move', { x: (e.clientX - rect.left) / canvasScale, y: (e.clientY - rect.top) / canvasScale });
      }
    });

    document.addEventListener('mouseup', () => { isDraggingCanvas = false; puzzleContainer.style.cursor = 'grab'; });

    puzzleContainer.addEventListener('wheel', (e) => {
      e.preventDefault();
      canvasScale = Math.max(0.3, Math.min(3, canvasScale * (e.deltaY > 0 ? 0.9 : 1.1)));
      updateCanvasTransform();
    });

    document.getElementById('zoomIn').onclick = () => { canvasScale = Math.min(3, canvasScale * 1.2); updateCanvasTransform(); };
    document.getElementById('zoomOut').onclick = () => { canvasScale = Math.max(0.3, canvasScale / 1.2); updateCanvasTransform(); };
    document.getElementById('zoomReset').onclick = () => { canvasScale = 0.8; canvasX = 50; canvasY = 20; updateCanvasTransform(); };

    // Get neighboring pieces
    function getNeighbors(pieceId) {
      const p = currentGame.pieces.find(x => x.id === pieceId);
      const { correctRow: row, correctCol: col } = p;
      const { cols, rows } = currentGame.gridSize;
      const neighbors = [];
      if (row > 0) neighbors.push({ id: (row-1)*cols+col, dx: 0, dy: -pieceHeight });
      if (row < rows-1) neighbors.push({ id: (row+1)*cols+col, dx: 0, dy: pieceHeight });
      if (col > 0) neighbors.push({ id: row*cols+(col-1), dx: -pieceWidth, dy: 0 });
      if (col < cols-1) neighbors.push({ id: row*cols+(col+1), dx: pieceWidth, dy: 0 });
      return neighbors;
    }

    // Piece dragging
    function onPieceMouseDown(e) {
      e.stopPropagation();
      const pieceId = parseInt(e.target.dataset.pieceId);
      const piece = currentGame.pieces.find(p => p.id === pieceId);
      if (piece.isPlaced || (piece.lockedBy && piece.lockedBy !== myPlayerId)) return;

      draggedPiece = piece;
      draggedGroup = pieceToPieceGroup.get(pieceId) || null;
      
      const el = pieceElements.get(pieceId);
      const rect = el.getBoundingClientRect();
      dragOffsetX = (e.clientX - rect.left) / canvasScale;
      dragOffsetY = (e.clientY - rect.top) / canvasScale;

      if (draggedGroup) {
        pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.add('dragging'));
      } else el.classList.add('dragging');

      socket.emit('piece:grab', { pieceId, groupId: draggedGroup });
      document.addEventListener('mousemove', onPieceMouseMove);
      document.addEventListener('mouseup', onPieceMouseUp);
    }

    function onPieceMouseMove(e) {
      if (!draggedPiece) return;
      const rect = puzzleCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / canvasScale - dragOffsetX + tabSize;
      const y = (e.clientY - rect.top) / canvasScale - dragOffsetY + tabSize;
      const dx = x - draggedPiece.currentX, dy = y - draggedPiece.currentY;

      if (draggedGroup) {
        const groupData = [];
        pieceGroups.get(draggedGroup).forEach(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX += dx; p.currentY += dy;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; }
          groupData.push({ id: pid, x: p.currentX, y: p.currentY });
        });
        socket.emit('piece:move', { pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY, groupId: draggedGroup, groupPieces: groupData });
      } else {
        draggedPiece.currentX = x; draggedPiece.currentY = y;
        const el = pieceElements.get(draggedPiece.id);
        if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        socket.emit('piece:move', { pieceId: draggedPiece.id, x, y });
      }
    }

    function onPieceMouseUp() {
      if (!draggedPiece) return;
      
      if (draggedGroup) pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.remove('dragging'));
      else pieceElements.get(draggedPiece.id)?.classList.remove('dragging');

      const boardLeft = 50, boardTop = 50;
      const threshold = Math.min(pieceWidth, pieceHeight) * 0.35;
      let placed = false, newGroup = null, groupPiecesData = null;

      // Check board placement
      const piecesToCheck = draggedGroup ? Array.from(pieceGroups.get(draggedGroup)) : [draggedPiece.id];
      let allCanPlace = piecesToCheck.every(pid => {
        const p = currentGame.pieces.find(x => x.id === pid);
        const cx = boardLeft + p.correctCol * pieceWidth, cy = boardTop + p.correctRow * pieceHeight;
        return Math.abs(p.currentX - cx) < threshold && Math.abs(p.currentY - cy) < threshold;
      });

      if (allCanPlace) {
        placed = true;
        groupPiecesData = piecesToCheck.map(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX = boardLeft + p.correctCol * pieceWidth;
          p.currentY = boardTop + p.correctRow * pieceHeight;
          p.isPlaced = true;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; el.classList.add('placed'); }
          return { id: pid, x: p.currentX, y: p.currentY, placed: true };
        });
      } else {
        // Check piece-to-piece snapping
        const snapThreshold = Math.min(pieceWidth, pieceHeight) * 0.3;
        
        for (const pid of piecesToCheck) {
          const p = currentGame.pieces.find(x => x.id === pid);
          const neighbors = getNeighbors(pid);
          
          for (const n of neighbors) {
            if (piecesToCheck.includes(n.id)) continue;
            const np = currentGame.pieces.find(x => x.id === n.id);
            if (!np || np.isPlaced) continue;
            
            const expectedX = np.currentX - n.dx, expectedY = np.currentY - n.dy;
            if (Math.abs(p.currentX - expectedX) < snapThreshold && Math.abs(p.currentY - expectedY) < snapThreshold) {
              const offsetX = expectedX - p.currentX, offsetY = expectedY - p.currentY;
              groupPiecesData = piecesToCheck.map(gpid => {
                const gp = currentGame.pieces.find(x => x.id === gpid);
                gp.currentX += offsetX; gp.currentY += offsetY;
                const el = pieceElements.get(gpid);
                if (el) { el.style.left = (gp.currentX - tabSize) + 'px'; el.style.top = (gp.currentY - tabSize) + 'px'; }
                return { id: gpid, x: gp.currentX, y: gp.currentY, placed: false };
              });

              const neighborGroupId = pieceToPieceGroup.get(n.id);
              if (draggedGroup && neighborGroupId) {
                const merged = new Set([...pieceGroups.get(draggedGroup), ...pieceGroups.get(neighborGroupId)]);
                pieceGroups.set(draggedGroup, merged);
                pieceGroups.delete(neighborGroupId);
                merged.forEach(id => pieceToPieceGroup.set(id, draggedGroup));
                newGroup = { pieceIds: Array.from(merged) };
              } else if (draggedGroup) {
                pieceGroups.get(draggedGroup).add(n.id);
                pieceToPieceGroup.set(n.id, draggedGroup);
                newGroup = { pieceIds: Array.from(pieceGroups.get(draggedGroup)) };
              } else if (neighborGroupId) {
                pieceGroups.get(neighborGroupId).add(draggedPiece.id);
                pieceToPieceGroup.set(draggedPiece.id, neighborGroupId);
                newGroup = { pieceIds: Array.from(pieceGroups.get(neighborGroupId)) };
              } else {
                const gid = nextGroupId++;
                pieceGroups.set(gid, new Set([draggedPiece.id, n.id]));
                pieceToPieceGroup.set(draggedPiece.id, gid);
                pieceToPieceGroup.set(n.id, gid);
                newGroup = { pieceIds: [draggedPiece.id, n.id] };
              }
              showToast('Pieces connected!');
              break;
            }
          }
          if (groupPiecesData) break;
        }
      }

      if (!groupPiecesData && draggedGroup) {
        groupPiecesData = Array.from(pieceGroups.get(draggedGroup)).map(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          return { id: pid, x: p.currentX, y: p.currentY, placed: p.isPlaced };
        });
      }

      socket.emit('piece:release', {
        pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY,
        placed, groupId: draggedGroup, groupPieces: groupPiecesData, newGroup
      });

      draggedPiece = null; draggedGroup = null;
      document.removeEventListener('mousemove', onPieceMouseMove);
      document.removeEventListener('mouseup', onPieceMouseUp);
    }

    // Touch support
    function onPieceTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const pieceId = parseInt(e.target.dataset.pieceId);
      const piece = currentGame.pieces.find(p => p.id === pieceId);
      if (piece.isPlaced || (piece.lockedBy && piece.lockedBy !== myPlayerId)) return;

      draggedPiece = piece;
      draggedGroup = pieceToPieceGroup.get(pieceId) || null;
      const el = pieceElements.get(pieceId);
      const rect = el.getBoundingClientRect();
      dragOffsetX = (touch.clientX - rect.left) / canvasScale;
      dragOffsetY = (touch.clientY - rect.top) / canvasScale;

      if (draggedGroup) pieceGroups.get(draggedGroup).forEach(pid => pieceElements.get(pid)?.classList.add('dragging'));
      else el.classList.add('dragging');

      socket.emit('piece:grab', { pieceId, groupId: draggedGroup });
      document.addEventListener('touchmove', onPieceTouchMove, { passive: false });
      document.addEventListener('touchend', onPieceTouchEnd);
    }

    function onPieceTouchMove(e) {
      e.preventDefault();
      if (!draggedPiece) return;
      const touch = e.touches[0];
      const rect = puzzleCanvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left) / canvasScale - dragOffsetX + tabSize;
      const y = (touch.clientY - rect.top) / canvasScale - dragOffsetY + tabSize;
      const dx = x - draggedPiece.currentX, dy = y - draggedPiece.currentY;

      if (draggedGroup) {
        const groupData = [];
        pieceGroups.get(draggedGroup).forEach(pid => {
          const p = currentGame.pieces.find(x => x.id === pid);
          p.currentX += dx; p.currentY += dy;
          const el = pieceElements.get(pid);
          if (el) { el.style.left = (p.currentX - tabSize) + 'px'; el.style.top = (p.currentY - tabSize) + 'px'; }
          groupData.push({ id: pid, x: p.currentX, y: p.currentY });
        });
        socket.emit('piece:move', { pieceId: draggedPiece.id, x: draggedPiece.currentX, y: draggedPiece.currentY, groupId: draggedGroup, groupPieces: groupData });
      } else {
        draggedPiece.currentX = x; draggedPiece.currentY = y;
        const el = pieceElements.get(draggedPiece.id);
        if (el) { el.style.left = (x - tabSize) + 'px'; el.style.top = (y - tabSize) + 'px'; }
        socket.emit('piece:move', { pieceId: draggedPiece.id, x, y });
      }
    }

    function onPieceTouchEnd() {
      onPieceMouseUp();
      document.removeEventListener('touchmove', onPieceTouchMove);
      document.removeEventListener('touchend', onPieceTouchEnd);
    }

    // API functions
    async function createNewGame(name, pName, imageFile, pieceCount) {
      const formData = new FormData();
      formData.append('gameName', name);
      formData.append('pieceCount', pieceCount);
      formData.append('image', imageFile);
      const res = await fetch('/api/games', { method: 'POST', body: formData });
      if (!res.ok) throw new Error('Failed');
      const data = await res.json();
      connectSocket();
      setTimeout(() => socket.emit('game:join', { gameId: data.gameId, playerName: pName }), 500);
    }

    async function joinGame(gameId, pName) {
      if (!socket) connectSocket();
      setTimeout(() => socket.emit('game:join', { gameId: gameId.toUpperCase(), playerName: pName }), 500);
    }

    // Event handlers
    document.getElementById('btnNewGame').onclick = () => { document.getElementById('playerName').value = playerName; openModal('newGameModal'); };
    document.getElementById('pieceSlider').oninput = (e) => document.getElementById('pieceCountDisplay').textContent = e.target.value + ' pieces';
    document.getElementById('imageUpload').onchange = (e) => {
      if (e.target.files[0]) { const p = document.getElementById('imagePreview'); p.src = URL.createObjectURL(e.target.files[0]); p.style.display = 'block'; }
    };
    document.getElementById('cancelNewGame').onclick = () => closeModal('newGameModal');
    document.getElementById('createGame').onclick = async () => {
      const name = document.getElementById('gameName').value || 'Inferno Puzzle';
      const pName = document.getElementById('playerName').value || 'Player';
      const imageFile = document.getElementById('imageUpload').files[0];
      if (!imageFile) { showToast('Select an image!'); return; }
      playerName = pName; localStorage.setItem('playerName', playerName);
      closeModal('newGameModal'); showToast('Creating puzzle...');
      try { await createNewGame(name, pName, imageFile, document.getElementById('pieceSlider').value); }
      catch { showToast('Failed to create'); }
    };

    document.getElementById('btnLoadGame').onclick = async () => {
      document.getElementById('loadPlayerName').value = playerName;
      openModal('loadGameModal');
      try {
        const games = await (await fetch('/api/games')).json();
        const list = document.getElementById('savedGamesList');
        if (!games.length) { list.innerHTML = '<div class="no-games">No saved games</div>'; return; }
        list.innerHTML = games.map(g => `<div class="saved-game-item" data-game-id="${g.id}"><img class="saved-game-thumb" src="${g.imageUrl}"><div class="saved-game-info"><div class="saved-game-name">${g.name}</div><div class="saved-game-meta">${g.totalPieces} pcs ‚Ä¢ ${g.id}</div></div><div class="saved-game-progress">${g.progress}%</div></div>`).join('');
        list.querySelectorAll('.saved-game-item').forEach(item => {
          item.onclick = () => {
            playerName = document.getElementById('loadPlayerName').value || 'Player';
            localStorage.setItem('playerName', playerName);
            closeModal('loadGameModal');
            joinGame(item.dataset.gameId, playerName);
          };
        });
      } catch { document.getElementById('savedGamesList').innerHTML = '<div class="no-games">Failed to load</div>'; }
    };
    document.getElementById('cancelLoadGame').onclick = () => closeModal('loadGameModal');

    let pendingJoinCode = '';
    document.getElementById('btnJoinGame').onclick = () => {
      const code = document.getElementById('joinCodeInput').value.trim();
      if (!code) { showToast('Enter a code!'); return; }
      pendingJoinCode = code;
      document.getElementById('joinPlayerName').value = playerName;
      openModal('joinNameModal');
    };
    document.getElementById('joinCodeInput').onkeypress = (e) => { if (e.key === 'Enter') document.getElementById('btnJoinGame').click(); };
    document.getElementById('cancelJoin').onclick = () => closeModal('joinNameModal');
    document.getElementById('confirmJoin').onclick = () => {
      playerName = document.getElementById('joinPlayerName').value || 'Player';
      localStorage.setItem('playerName', playerName);
      closeModal('joinNameModal');
      joinGame(pendingJoinCode, playerName);
    };

    document.getElementById('btnUpdateImage').onclick = () => openModal('updateImageModal');
    document.getElementById('newImageUpload').onchange = (e) => {
      if (e.target.files[0]) { const p = document.getElementById('newImagePreview'); p.src = URL.createObjectURL(e.target.files[0]); p.style.display = 'block'; }
    };
    document.getElementById('cancelUpdateImage').onclick = () => closeModal('updateImageModal');
    document.getElementById('confirmUpdateImage').onclick = async () => {
      const imageFile = document.getElementById('newImageUpload').files[0];
      if (!imageFile) { showToast('Select an image!'); return; }
      closeModal('updateImageModal'); showToast('Updating...');
      const formData = new FormData(); formData.append('image', imageFile);
      try { await fetch(`/api/games/${currentGame.id}/image`, { method: 'POST', body: formData }); }
      catch { showToast('Failed'); }
    };

    document.getElementById('btnShare').onclick = () => {
      if (currentGame) { navigator.clipboard.writeText(`${location.origin}?game=${currentGame.id}`); showToast('Link copied!'); }
    };

    document.getElementById('btnHome').onclick = () => {
      if (socket) { socket.disconnect(); socket = null; }
      currentGame = null; pieceElements.clear(); pieceGroups.clear(); pieceToPieceGroup.clear(); nextGroupId = 1;
      remoteCursors.forEach(c => c.remove()); remoteCursors.clear();
      puzzleCanvas.innerHTML = '<div class="puzzle-board" id="puzzleBoard"></div>';
      document.getElementById('mainMenu').classList.remove('hidden');
      puzzleContainer.classList.remove('active');
      document.getElementById('gameInfo').classList.remove('active');
      document.getElementById('playersPanel').classList.remove('active');
      document.getElementById('zoomControls').classList.remove('active');
      document.getElementById('minimap').classList.remove('active');
      document.getElementById('btnHome').style.display = 'none';
      document.getElementById('btnUpdateImage').style.display = 'none';
      document.getElementById('btnShare').style.display = 'none';
    };

    document.getElementById('victoryHome').onclick = () => {
      document.getElementById('victoryOverlay').classList.remove('active');
      document.getElementById('btnHome').click();
    };

    // Check URL for game code
    const urlGame = new URLSearchParams(location.search).get('game');
    if (urlGame) { document.getElementById('joinCodeInput').value = urlGame; document.getElementById('btnJoinGame').click(); }
  </script>
</body>
</html>
